## 数组

### 217. 存在重复元素

**【代码】**

~~~java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int x : nums){
            if(!set.add(x))
                return true;
        }
        return false;
    }
}
~~~



### 88.合并两个有序数组

【题目描述】：

​		给你两个按非递减顺序排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

​		请你合并nums2到nums1 中，使合并后的数组同样按 非递减顺序排列。

​		注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

【思路】：

​		利用两个数组非递减顺序排列的性质，可以通过双指针对两个数组进行遍历。此外，可以发现数组nums1中后面包含额外的空间，可以直接将元素复制到nums1中，从而使空间复杂度达到O(1)。

【代码】：

~~~java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m-1, p2 = n-1, tail = m+n-1;
        int cur;

        while(p1 >= 0 || p2 >=0){
            if(p1 < 0){
                cur = nums2[p2--];
            }else if(p2 < 0){
                cur = nums1[p1--];
            }else if(nums1[p1] < nums2[p2]){
                cur = nums2[p2--];
            }else{
                cur = nums1[p1--];
            }

            nums1[tail--] = cur;
        }
    }
}
~~~



### 169. [多数元素](https://leetcode-cn.com/problems/majority-element/)

【题目描述】：

​		给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

​		你可以假设数组是非空的，并且给定的数组总是存在多数元素。



【思路】：

- 通过哈希表对每个数字以及其出现的次数进行储存，然后对哈希表进行遍历，找出众数：

  ~~~java
  class Solution {
      public int majorityElement(int[] nums) {
          int n = nums.length;
          //构建哈希表
          HashMap<Integer, Integer> map = new HashMap<>();
          for(int num : nums){
              if(!map.containsKey(num)){
                  map.put(num, 1);
              }else{
                  map.put(num, map.get(num) + 1);
              }
          }
  
          //遍历哈希表，寻找众数
          for(HashMap.Entry<Integer, Integer> entry : map.entrySet()){
              if(entry.getValue() > n/2)
                  return entry.getKey();
          }
          return 0;
      }
  }
  ~~~

  时间复杂度$O(n)$, 空间复杂度$O(n)$；

- 快速排序，排序好数组的up [n/2]位置即为众数；

- 分治；

- **Boyer-Moore投票算法**，在该题的题解中提供的思路，其思路为：

  如果把众数记为+1，把其他数记为-1，并对所有数求和，其总和一定大于0，即众数的数量相比其他数更多。

  根据此思路，Boyer-Moore算法维护一个候选众数`candidate`和出现次数`count`。初始时，`count`的值为0。然后对于整个数组进行遍历，对其中的元素`x`，如果遍历到`x`时`count`为0，则将`x`作为`candidate`，并对`x`进行判断：

  - `x`与`candidate`相等，则`count`加1；
  - `x`与`candidate`不等，则`count`减1；

  在整个数组遍历完成后，`candidate`即为该数组的众数。



【代码】：

~~~java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for(int num : nums){
            //确定候选众数
            if(count == 0){
                candidate = num;
            }

            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }
}
~~~



### [15.三数之和](https://leetcode-cn.com/problems/3sum/submissions/)

【代码】：

~~~java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        int len = nums.length;

        for(int first = 0; first < len; first++){
            if(first > 0 && nums[first] == nums[first-1]){
                continue;
            }

            int second = first+1;
            int third = len-1;
            int remain = -nums[first];
            int mark = Integer.MAX_VALUE;      //标记，防止相同数字重复遍历

            while(second < third){
                if(nums[second] + nums[third] < remain){
                    second += 1;
                }else if(nums[second] + nums[third] > remain){
                    third -= 1;
                }else{
                    if(nums[second] != mark){
                        List<Integer> curAns = new ArrayList<>();
                        curAns.add(nums[first]);
                        curAns.add(nums[second]);
                        curAns.add(nums[third]);
                        ans.add(curAns);
                        mark = nums[second];
                        second += 1;
                        third -= 1;
                    }else{
                        second += 1;
                    }
                    
                }
            }
        }
        return ans;
    }
}
~~~



~~~java
//从小到大排序，外排序，多路归并
public class LoserTree {
    int[] losers;//败者树（堆）0位置为胜者后面都是败者
    List<Queue<Integer>> items;//队列模拟待取的n个文件
    int size;//多少路排序，items的数量
    int hasItemSize;//多少个队列没取完
    public LoserTree(List<Queue<Integer>> items){
        this.items = items;
        size = items.size();
        losers = new int[items.size()];
        Arrays.fill(losers,-1);
        hasItemSize = size;
        //首次，需要把所有数都装进去
        for(int i = 0; i < size; i++){
            sort(i);
        }
    }

    //当前排列的胜者
    public int findWinner(){
        return items.get(losers[0]).peek();
    }

    private void sort(){
        //胜者离开，把下一个元素加进去
        items.get(losers[0]).poll();
        if(items.get(losers[0]).isEmpty()){
            --hasItemSize;
        }
        if(hasItem()){
            sort(losers[0]);
        }
    }

    private void sort(int i){
        //堆排但是不直接排序，只记录比较中败者，胜者继续走上父节点
        int j = (i+size)/2;
        int itemIndex = i;
        while(j > 0 && itemIndex>=0){
            int itemValue = getIndexVal(itemIndex);
            int parentVal =  getIndexVal(losers[j]);
            if(losers[j]==-1 || parentVal<itemValue){
                int temp = itemIndex;
                itemIndex = losers[j];
                losers[j] = temp;
                itemValue = getIndexVal(itemIndex);
            }

            //赢家做首个点
            if(losers[0]==-1 || itemValue<getIndexVal(losers[0])){
                losers[0] = itemIndex;
            }
            j=j/2;

        }
    }

    private int getIndexVal(int index){
        //没填过或者无值的自动采用最大值，使其成为败者
        return index==-1 || items.get(index).isEmpty()?Integer.MAX_VALUE:items.get(index).peek();
    }


    private boolean hasItem(){
        return hasItemSize>0;
    }

    public static void main(String[] args) {
        //假设当前有 4 个归并段
        Queue<Integer> queue0 = new LinkedList<>();
        Queue<Integer> queue1 = new LinkedList<>();
        Queue<Integer> queue2 = new LinkedList<>();
        Queue<Integer> queue3 = new LinkedList<>();
        //注意，这里队列模仿的小文件已经是有序
        Integer[] source0 = {2, 8, 16, 23, 26};
        Integer[] source1 = {4, 13, 22, 23, 29};
        Integer[] source2 = {5, 12, 15, 23, 32};
        Integer[] source3 = {3, 7, 17, 23, 28};
        queue0.addAll(Arrays.asList(source0));
        queue1.addAll(Arrays.asList(source1));
        queue2.addAll(Arrays.asList(source2));
        queue3.addAll(Arrays.asList(source3));

        LoserTree loserTree = new LoserTree(Arrays.asList(queue0,queue1,queue2,queue3));
        while(loserTree.hasItem()){
            //输出胜者
            System.out.println(loserTree.findWinner());
            //移动，找出下一个胜者
            loserTree.sort();
        }
    }
}
~~~





