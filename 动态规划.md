## 动态规划

### 剑指offer 42.连续子数组最大和

【题目描述】：

​		输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

<img src="动态规划.assets/image-20210318171416822.png" alt="image-20210318171416822" style="zoom:80%;" />



【思路】：

- 状态定义：设动态规划表dp，dp[i]代表以元素nums[i]为结尾元素的连续子数组最大和。
- 转移方程：
  - 当$dp[i-1] > 0$时，执行$dp[i] = dp[i-1] + nums[i]$；
  - 当$dp[i-1] \leq 0$时，执行$dp[i] = nums[i]$；

- 初始状态：$dp[0] = nums[0]$；
- 返回值：返回dp列表中的最大值，即为全局最大值。

**空间复杂度降低：**

​		由于`dp[i]`只与`dp[i-1]`和`nums[i]`有关系，因此可将原数组`nums`作为dp列表，直接在`nums`上修改。并设置全局变量，在遍历数组时保存最大值。可以使空间复杂度从$O(n)$降至$O(1)$。



【代码】：

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        for(int i = 1; i < nums.length; i++) {
            nums[i] += Math.max(nums[i - 1], 0);
            res = Math.max(res, nums[i]);
        }
        return res;
    }
}
~~~



### 剑指offer 63. 股票的最大利润

【题目描述】：		

​		假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

<img src="动态规划.assets/image-20210323171747630.png" alt="image-20210323171747630" style="zoom:80%;" />



【思路】：

​		最直接的思路是采用暴力的方法遍历，以每一天的价格作为买入时间，计算其可能获得的最大收益，最后取最大值，即$max(prices[j] - prices[i])$（i<j)，时间复杂度为$O(n^2)$。

​		进一步优化，我们希望只对数组进行一次遍历得到结果，可以采取动态规划的思路。

- 状态定义：设动态规划表dp，dp[i]代表前i天的最大收益。
- 转移方程：$dp[i] = max(dp[i-1], prices[i] - minprice)$，其中minprice为前i天的最小买入价格；

- 初始状态：$dp[0] = 0$，minprice = Integer.MAX_VALUE；
- 返回值：返回dp列表中的最大值，即为全局最大值。

**空间复杂度降低：**

​		可以设置一个值maxprice作为返回值，保存每一天为止的最大收益。



【代码】：

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        //maxprofit:最大收益, minprice:最小买入
        int maxprofit = 0, minprice = Integer.MAX_VALUE;
        for(int i=0; i<prices.length; i++){
            minprice = Math.min(minprice, prices[i]);
            maxprofit = Math.max(maxprofit, prices[i]-minprice);
        }
        return maxprofit;
    }
}
~~~

